# Alura - PostgreSQL: Primeiros Passos com SQL

## Avançando com Consultas

### Ordenando as consultas

Nesta aula, aprenderemos como organizar consultas SQL utilizando `ORDER BY`. Essa cláusula é essencial para tornar a apresentação dos resultados mais clara, especialmente em tabelas grandes. Para isso, criaremos uma tabela simulando o cadastro de funcionários:

```sql
CREATE TABLE funcionarios(
    id SERIAL PRIMARY KEY,
    matricula VARCHAR(10),
    nome VARCHAR(255),
    sobrenome VARCHAR(255)
);
```

Agora, inserimos alguns registros:

```sql
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M001', 'Diogo', 'Mascarenhas');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M002', 'Vinícius', 'Dias');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M003', 'Nico', 'Steppat');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M004', 'João', 'Roberto');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M005', 'Diogo', 'Mascarenhas');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M006', 'Alberto', 'Martins');
```

Executando `SELECT * FROM funcionarios;`, confirmamos que os registros foram incluídos corretamente.

---

### **Usando `ORDER BY` para ordenar os resultados**

O comando `ORDER BY` nos permite definir a ordem em que os resultados serão exibidos. Por padrão, a ordenação ocorre em ordem crescente:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome;
```

Caso queiramos ordenar os resultados em ordem decrescente, utilizamos `DESC`:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome DESC;
```

Também podemos ordenar por múltiplas colunas. Por exemplo, se quisermos organizar os registros primeiro pelo `nome` e depois pela `matricula`, usamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome, matricula;
```

Aqui, os registros serão ordenados pelo `nome` de forma crescente e, em casos de nomes repetidos, a matrícula definirá a ordem.

Para inverter a ordem da matrícula, aplicamos `DESC` somente a ela:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome, matricula DESC;
```

---

### **Ordenação por posição da coluna**

Outra forma de organizar os registros é usando a posição da coluna ao invés do seu nome. Na nossa tabela:

- `id` → posição 1
- `matricula` → posição 2
- `nome` → posição 3
- `sobrenome` → posição 4

Podemos ordenar pela quarta coluna (`sobrenome`) informando sua posição:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 4;
```

Se quisermos organizar por múltiplas colunas, como `nome`, `sobrenome` e `matricula`, usamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 3, 4, 2;
```

Isso gera uma ordenação pelos nomes primeiro, depois pelos sobrenomes e, por último, pelas matrículas.

Agora, adicionamos um novo registro para ver a ordenação em ação:

```sql
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M007', 'Diogo', 'Oliveira');
```

Executamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 3, 4, 2;
```

Aqui, os registros com o nome "Diogo" aparecem juntos, mas, como o sobrenome "Mascarenhas" vem antes de "Oliveira" alfabeticamente, ele aparece primeiro.

---

### **Evitando Ambiguidade ao Ordenar Colunas Compartilhadas**

Ao trabalhar com `JOIN`, pode haver campos com o mesmo nome em diferentes tabelas. Para evitar erros, especificamos o nome da tabela ao ordenar:

```sql
SELECT 
       aluno.id AS aluno_id,
       aluno.nome AS "Nome do Aluno",
       curso.id AS curso_id,
       curso.nome AS "Nome do Curso"
  FROM aluno
  JOIN aluno_curso ON aluno_curso.aluno_id = aluno.id
  JOIN curso ON curso.id = aluno_curso.curso_id
  ORDER BY aluno.nome;
```

Esse comando ordena os registros pelo nome do aluno. Se quisermos organizá-los pelo nome do curso primeiro, fazemos:

```sql
ORDER BY curso.nome, aluno.nome;
```

Agora, os cursos aparecem em ordem crescente, e dentro de cada curso os alunos estão ordenados alfabeticamente.

---

## **Limitando as consultas**

Quando uma tabela contém muitos registros, podemos limitar a quantidade de resultados exibidos com a cláusula `LIMIT`. Isso torna as buscas mais eficientes e evita retornos excessivos.

Para exibir apenas os cinco primeiros registros, utilizamos:

```sql
SELECT * 
  FROM funcionarios
  LIMIT 5;
```

Para ordenar antes de limitar os resultados:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome
  LIMIT 5;
```

---

### **Pulando registros com `OFFSET`**

Se quisermos exibir resultados após ignorar um certo número de linhas, usamos `OFFSET`. No exemplo abaixo, pulamos o primeiro registro e exibimos os cinco seguintes:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY id
  LIMIT 5
  OFFSET 1;
```

Podemos testar outras combinações:

```sql
OFFSET 2; -- Exibe registros a partir do ID 3
OFFSET 3; -- Exibe registros a partir do ID 4
```

Caso `OFFSET` ultrapasse o número total de registros disponíveis, a consulta pode retornar um conjunto menor de resultados.

![Tela Select com LIMIT OFFSET](./images/TelaSelectComLimitOffset.png)

---

## **Conclusão**

Os comandos `ORDER BY`, `LIMIT` e `OFFSET` são essenciais para otimizar consultas SQL. Eles permitem organizar os resultados, limitar sua quantidade e definir quais registros devem ser exibidos. Na próxima aula, aprofundaremos outros aspectos para manipulação avançada dos dados.

---

### Observação

No SQL Server, o comando `LIMIT` não existe. Em vez disso, usamos `TOP` para limitar o número de registros retornados em uma consulta:

```sql
SELECT TOP 5 * FROM funcionarios;
```

Já o `OFFSET` faz parte da cláusula `ORDER BY` em conjunto com `FETCH`, que funciona de forma semelhante ao `LIMIT` no PostgreSQL:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome
  OFFSET 2 ROWS
  FETCH NEXT 5 ROWS ONLY;
```

Esse comando ignora as duas primeiras linhas e exibe os cinco registros seguintes. 

---

## Classificação de vestibular - Testando conhecimento adquirido

Você está trabalhando em uma universidade, que aplicou uma prova de vestibular e precisa saber os 100 últimos colocados, ordenados por ordem alfabética.

Para tal, há a seguinte SQL:

```sql
SELECT nome, nota
FROM notas
```

Complete a consulta SQL acima, para listar os 100 últimos alunos com as menores notas, ordenados primeiro por nota(ascendente) e depois por nome (A-Z).

![Pergunta e Resposta teste Conceito ORDER BY, LIMIT e OFFSET](./images/Teste-ConceitoOrderByLimitOffset.png)

---

### Funções de agregação

Nesta aula aprenderemos como trabalhar com as funções de agregação para integrar registros em um único resultado. Nosso primeiro passo será conhecer os comandos de agregação mais comuns.

```sql
-- COUNT - Retorna a quantidade de registros
-- SUM -   Retorna a soma dos registros
-- MAX -   Retorna o maior valor dos registros
-- MIN -   Retorna o menor valor dos registros
-- AVG -   Retorna a média dos registros
```

Na [documentação do postgre](https://www.postgresql.org/docs/current/functions-aggregate.html) existem várias outras funções de agregação que podemos explorar, mas trabalharemos com as principais. Para isso, voltaremos à tabela "funcionarios" com SELECT * FROM funcionarios; e nos basearemos no "id" para realizarmos as agregações.

Para contarmos os registros da nossa tabela, utilizaremos o COUNT() . Esse comando aceita um nome de um campo ou o * , representa todos os campos. No nosso caso, utilizaremos o campo "id".

```sql
SELECT COUNT (id)
  FROM funcionarios;
```

Ao executarmos esse comando, teremos o retorno de quantos registros existem no nosso banco, que no caso são "7". Caso alteremos o número "id", como nas aulas passadas, esse comando continuará retornando a quantidade de registros, e não o valor do "id" mais alto.

O comando SUM() soma os valores. Ao codarmos SUM(id) ele retornará "28", ou seja, o somatório do valor de cada "id". Em outras palavras, esse comando calculou "1+2+3+4+5+6+7 = 28".

Ao escrevermos o comando MAX(), o programa retorna o maior valor do campo declarado, portanto MAX(id) resulta em "7", o maior "id". Por outro lado, para sabermos o menor "id", codamos MIN(id), que retorna "1".

O comando AVG() irá retornar a média dos valores, então AVG(id) retorna o número "4", porque é o resultado da soma de todos os valores (28) dividida pela quantidade de registros (7).

O valor da média é sucedido por várias casas decimais, por isso precisamos aumentar a coluna "avg" para visualizar esse valor. Para reduzir a quantidade de casas decimais, codamos ROUND() . Esse comando arredonda o resultado entre parênteses, diminuindo as casas decimais para um valor declarado. Por exemplo, para termos apenas duas casas decimais na nossa média, podemos escrever ROUND(AVG(id), 2) . Para vermos apenas o número inteiro, declaramos a quantidade de casas decimais como "0".

```sql
SELECT COUNT (id),
       SUM(id),
       MAX(id),
       MIN(id),
       ROUND(AVG(id),0)
  FROM funcionarios;
```

![Tela Retorno Select com Funções de Agregação](./images/TelaRetornoFuncoesAgregacao.png)

Basicamente essas são as funções de agregação. Conseguimos agrupar os valores e retornamos, em um único registro, os valores agrupamentos de cada comando.

Na próxima aula aprenderemos os comandos GROUP BY's, que permitem outras manipulações de agrupamento.

---

### Agrupando consultas

Nesta aula aprenderemos como realizar agrupamentos em consultas. Por exemplo, o código SELECT * FROM funcionarios; retorna vários nomes, mas alguns deles se repetem. Então aprenderemos como listar os nomes sem haver repetição.

Adicionando o comando ORDER BY nome; à nossa busca, perceberemos a presença de três "Diogo"'s. Existem duas formas desse nome não se repetir nos resultados. A primeira que conheceremos será a partir do DISTINCT.

```sql
SELECT DISTINCT
        nome
  FROM funcionarios
  ORDER BY nome;
```

O DISTINCT garante que os dados do campo solicitado não se repitam, a partir do agrupamento de informações. No nosso exemplo, estamos aplicando ao campo "nome", então ao executarmos o código acima, a lista retorna "Diogo" uma única vez. Observemos o que acontece se, além do nome, pedirmos o sobrenome.

```sql
SELECT DISTINCT
        nome,
        sobrenome
  FROM funcionarios
  ORDER BY nome;
```

Agora temos o retorno de dois "Diogo"'s, mas apenas um deles tem o sobrenome Mascarenhas, isso porque o agrupamento considerou o sobrenome para remover os registros duplicados. Contudo, como faríamos para contar quantos "Diogo Mascarenhas"'s temos no nosso banco? Vamos tentar com o COUNT(*).

```sql
SELECT DISTINCT
       nome,
       sobrenome,
       COUNT(*)
  FROM funcionarios
  ORDER BY nome;
```

Esse código retorna uma mensagem de erro, informando que nossos dados precisam estar no GROUP BY .

O comando GROUP BY é um agrupamento para realização de buscas com funções de agregação. Em outras palavras, se o agrupamento da busca não precisar de agregação, realizamos com DISTINCT , do contrário, codaremos com GROUP BY .

```sql
SELECT
       nome,
       sobrenome,
       COUNT(*)
  FROM funcionarios
  GROUP BY nome, sobrenome
  ORDER BY nome;
```

Executando esse código, notamos que função COUNT() retornou a quantidade de dados agrupados no nome "Diogo".

Além do nome do campo, também podemos usar o número que representa a posição que ele ocupa, da mesma forma que aprendemos na aula de ORDER BY . Então podemos substituir nosso comando por GROUP BY 1, 2 , obtendo o mesmo retorno.

Para entendermos melhor esse agrupamento, faremos simulações com as tabelas "aluno", "curso" e "aluno_curso", criadas nas últimas aulas. Nossa primeira situação será contar todos os cursos com alunos. Para isso, precisamos do retorno dessas tabelas.

```sql
SELECT *
    FROM aluno
    JOIN aluno_curso ON aluno.id = aluno_curso.aluno_id
    JOIN curso ON curso.id = aluno_curso.curso_id
```

Esse código retorna os nomes e id's dos alunos matriculados em cursos, assim como os nomes e id's dos cursos em questão. Sendo assim, vemos que o curso de HTML tem dois usuários enquanto o de CSS tem apenas um. Façamos uma nova busca que mostre os nomes dos cursos e a quantidade de alunos em cada um deles. Além disso, ordenaremos os dados pelo nome, informando a posição do campo.

```sql
SELECT curso.nome,
        COUNT(aluno.id)
    FROM aluno
    JOIN aluno_curso ON aluno.id = aluno_curso.aluno_id
    JOIN curso ON curso.id = aluno_curso.curso_id
    GROUP BY 1
    ORDER BY 1
```

Executando o código, constatamos que o count retornou a quantidade de alunos por curso, contados pela quantidade de id's. Nisso, notamos que curso de CSS tem um aluno e no curso do HTML tem dois alunos.

Essas são as formas de trabalhar com agrupamentos.

---

### Filtrando consultas agrupadas

Nesta aula aprenderemos como filtrar consultas agrupadas. Começaremos consultando a tabela de alunos com SELECT * FROM aluno; , obtendo o retorno dos três registros. Em seguida, buscaremos a tabela "aluno_curso" com SELECT * FROM aluno_curso , retornando os cursos em que cada aluno se matriculou. Por fim, checaremos a tabela "curso" com SELECT * FROM curso; para obtermos os cursos registrados.

Após checarmos essas informações, tentaremos descobrir quais cursos não têm alunos matriculados. Essa informação pode ser utilizada para, por exemplo, um relatório ou a exclusão do curso. Para isso, precisamos, inicialmente exibir todos os cursos, tanto com alunos matriculados quanto os sem alunos.

```sql
SELECT *
    FROM curso
    LEFT JOIN aluno_curso ON aluno_curso.curso_id = curso.id
    LEFT JOIN aluno ON aluno.id = aluno_curso.aluno_id
```

Nos resultados constatamos que, dos três cursos, o de Javascript é o único sem alunos matriculados. Outra forma de analisarmos essa informação é exibindo na busca a quantidade de alunos em cada curso, utilizando o comando COUNT().

```text
Lembrete: Sempre que aplicarmos um agrupamento na busca, é necessário codarmos o comando GROUP BY nome_ou_posição_do_campo .
```

```sql
SELECT curso.nome,
        COUNT (aluno.id)
    FROM curso
    LEFT JOIN aluno_curso ON aluno_curso.curso_id = curso.id
    LEFT JOIN aluno ON aluno.id = aluno_curso.aluno_id
GROUP BY 1
```

Os resultados mostram a quantidade de alunos por curso, sendo "0" em Javascript, "1" em CSS e "2" em HTML. Agora podemos filtrar esses dados. Aprendemos que os filtros utilizam WHERE , então escreveremos WHERE COUNT(aluno.id) = 0 .

```sql
SELECT curso.nome,
        COUNT (aluno.id)
    FROM curso
    LEFT JOIN aluno_curso ON aluno_curso.curso_id = curso.id
    LEFT JOIN aluno ON aluno.id = aluno_curso.aluno_id
    WHERE COUNT(aluno.id) = 0
GROUP BY 1
```

Recebemos uma mensagem de erro com esse código. Isso aconteceu porque o GROUP BY utiliza funções de agrupamento que não funcionam com o WHERE . Se substituirmos no código WHERE COUNT(aluno.id) = 0 por WHERE nome.curso = 'Javascript' , a tabela retorna o curso de Javascript e informa que tem zero alunos matriculados.

```sql
SELECT curso.nome,
       COUNT(aluno.id)    
  FROM curso
  LEFT JOIN aluno_curso ON aluno_curso.curso_id = curso.id
  LEFT JOIN aluno ON aluno.id = aluno_curso.aluno_id
  WHERE curso.nome = 'Javascritp'
GROUP BY 1
```

Entretanto, não queremos isso, porque nem sempre saberemos o curso sem alunos. Portanto, nosso filtro precisa ser com base na função de agrupamento.

Para isso, após o GROUP BY , adicionaremos o HAVING , que é um comando de filtro assim como o WHERE . A diferença da filtragem com HAVING é a possibilidade de utilizar as funções de agrupamento que aprendemos, enquanto o WHERE filtra a partir dos campos. Vamos conferir isso nos testes.

```sql
SELECT curso.nome,
        COUNT (aluno.id)
    FROM curso
    LEFT JOIN aluno_curso ON aluno_curso.curso_id = curso.id
    LEFT JOIN aluno ON aluno.id = aluno_curso.aluno_id
    --WHERE curso.nome = 'Javascritp'
GROUP BY 1
    HAVING COUNT (aluno.id) = 0
```

```text
Dica: Quando quiser adicionar um comentário no código do pgAdmin, utilize -- . Dessa forma, a linha com esse sinal no começo não será lida durante a execução do código.
```

Ao executarmos o código, obtemos o retorno do curso de Javascript com zero alunos matriculados.

Se quisermos retornar os curso com alunos, trocaremos o sinal de igualdade ( = ) pelo sinal de maior que ( > ), ou seja, HAVING COUNT(aluno.id) > 0 . Dessa forma retornamos somente os cursos com alunos.

Observemos outro exemplo a partir da tabela "funcionarios". Se nos pedissem para listar os funcionários com nome duplicado, poderíamos usar o seguinte código.

```sql
SELECT nome
    FROM funcionarios
    GROUP BY nome
    HAVING COUNT(id) > 1;
```

Nesse código, solicitamos que o programa retorne o nome dos funcionários que aparecem mais de uma vez. No caso, o "Diogo". Além disso, poderíamos pedir a quantidade de duplicações com COUNT().

```sql
SELECT nome,
       COUNT(id)
    FROM funcionarios
    GROUP BY nome
    HAVING COUNT(id) > 1;
```

Agora além de obtermos o nome "Diogo", fomos informados que ele se repete três vezes no nosso banco.

Para retornarmos a relação de funcionários que não têm o nome duplicado, trocaríamos o sinal > por =, ou seja, HAVING COUNT(id) = 1; .

Então aprendemos que podemos fazer manipulações e filtros com HAVING e WHERE, sendo que o having é utilizado quando há agregações, e o where nas outras ocasiões.

---
