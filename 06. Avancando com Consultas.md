# Alura - PostgreSQL: Primeiros Passos com SQL

## Avançando com Consultas

### Ordenando as consultas

Nesta aula, aprenderemos como organizar consultas SQL utilizando `ORDER BY`. Essa cláusula é essencial para tornar a apresentação dos resultados mais clara, especialmente em tabelas grandes. Para isso, criaremos uma tabela simulando o cadastro de funcionários:

```sql
CREATE TABLE funcionarios(
    id SERIAL PRIMARY KEY,
    matricula VARCHAR(10),
    nome VARCHAR(255),
    sobrenome VARCHAR(255)
);
```

Agora, inserimos alguns registros:

```sql
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M001', 'Diogo', 'Mascarenhas');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M002', 'Vinícius', 'Dias');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M003', 'Nico', 'Steppat');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M004', 'João', 'Roberto');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M005', 'Diogo', 'Mascarenhas');
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M006', 'Alberto', 'Martins');
```

Executando `SELECT * FROM funcionarios;`, confirmamos que os registros foram incluídos corretamente.

---

### **Usando `ORDER BY` para ordenar os resultados**

O comando `ORDER BY` nos permite definir a ordem em que os resultados serão exibidos. Por padrão, a ordenação ocorre em ordem crescente:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome;
```

Caso queiramos ordenar os resultados em ordem decrescente, utilizamos `DESC`:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome DESC;
```

Também podemos ordenar por múltiplas colunas. Por exemplo, se quisermos organizar os registros primeiro pelo `nome` e depois pela `matricula`, usamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome, matricula;
```

Aqui, os registros serão ordenados pelo `nome` de forma crescente e, em casos de nomes repetidos, a matrícula definirá a ordem.

Para inverter a ordem da matrícula, aplicamos `DESC` somente a ela:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome, matricula DESC;
```

---

### **Ordenação por posição da coluna**

Outra forma de organizar os registros é usando a posição da coluna ao invés do seu nome. Na nossa tabela:

- `id` → posição 1
- `matricula` → posição 2
- `nome` → posição 3
- `sobrenome` → posição 4

Podemos ordenar pela quarta coluna (`sobrenome`) informando sua posição:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 4;
```

Se quisermos organizar por múltiplas colunas, como `nome`, `sobrenome` e `matricula`, usamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 3, 4, 2;
```

Isso gera uma ordenação pelos nomes primeiro, depois pelos sobrenomes e, por último, pelas matrículas.

Agora, adicionamos um novo registro para ver a ordenação em ação:

```sql
INSERT INTO funcionarios (matricula, nome, sobrenome) VALUES ('M007', 'Diogo', 'Oliveira');
```

Executamos:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY 3, 4, 2;
```

Aqui, os registros com o nome "Diogo" aparecem juntos, mas, como o sobrenome "Mascarenhas" vem antes de "Oliveira" alfabeticamente, ele aparece primeiro.

---

### **Evitando Ambiguidade ao Ordenar Colunas Compartilhadas**

Ao trabalhar com `JOIN`, pode haver campos com o mesmo nome em diferentes tabelas. Para evitar erros, especificamos o nome da tabela ao ordenar:

```sql
SELECT 
       aluno.id AS aluno_id,
       aluno.nome AS "Nome do Aluno",
       curso.id AS curso_id,
       curso.nome AS "Nome do Curso"
  FROM aluno
  JOIN aluno_curso ON aluno_curso.aluno_id = aluno.id
  JOIN curso ON curso.id = aluno_curso.curso_id
  ORDER BY aluno.nome;
```

Esse comando ordena os registros pelo nome do aluno. Se quisermos organizá-los pelo nome do curso primeiro, fazemos:

```sql
ORDER BY curso.nome, aluno.nome;
```

Agora, os cursos aparecem em ordem crescente, e dentro de cada curso os alunos estão ordenados alfabeticamente.

---

## **Limitando as consultas**

Quando uma tabela contém muitos registros, podemos limitar a quantidade de resultados exibidos com a cláusula `LIMIT`. Isso torna as buscas mais eficientes e evita retornos excessivos.

Para exibir apenas os cinco primeiros registros, utilizamos:

```sql
SELECT * 
  FROM funcionarios
  LIMIT 5;
```

Para ordenar antes de limitar os resultados:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome
  LIMIT 5;
```

---

### **Pulando registros com `OFFSET`**

Se quisermos exibir resultados após ignorar um certo número de linhas, usamos `OFFSET`. No exemplo abaixo, pulamos o primeiro registro e exibimos os cinco seguintes:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY id
  LIMIT 5
  OFFSET 1;
```

Podemos testar outras combinações:

```sql
OFFSET 2; -- Exibe registros a partir do ID 3
OFFSET 3; -- Exibe registros a partir do ID 4
```

Caso `OFFSET` ultrapasse o número total de registros disponíveis, a consulta pode retornar um conjunto menor de resultados.

![Tela Select com LIMIT OFFSET](./images/TelaSelectComLimitOffset.png)

---

## **Conclusão**

Os comandos `ORDER BY`, `LIMIT` e `OFFSET` são essenciais para otimizar consultas SQL. Eles permitem organizar os resultados, limitar sua quantidade e definir quais registros devem ser exibidos. Na próxima aula, aprofundaremos outros aspectos para manipulação avançada dos dados.

---

### Observação

No SQL Server, o comando `LIMIT` não existe. Em vez disso, usamos `TOP` para limitar o número de registros retornados em uma consulta:

```sql
SELECT TOP 5 * FROM funcionarios;
```

Já o `OFFSET` faz parte da cláusula `ORDER BY` em conjunto com `FETCH`, que funciona de forma semelhante ao `LIMIT` no PostgreSQL:

```sql
SELECT * 
  FROM funcionarios
  ORDER BY nome
  OFFSET 2 ROWS
  FETCH NEXT 5 ROWS ONLY;
```

Esse comando ignora as duas primeiras linhas e exibe os cinco registros seguintes. 

---

## Classificação de vestibular - Testando conhecimento adquirido

Você está trabalhando em uma universidade, que aplicou uma prova de vestibular e precisa saber os 100 últimos colocados, ordenados por ordem alfabética.

Para tal, há a seguinte SQL:

```sql
SELECT nome, nota
FROM notas
```

Complete a consulta SQL acima, para listar os 100 últimos alunos com as menores notas, ordenados primeiro por nota(ascendente) e depois por nome (A-Z).

![Pergunta e Resposta teste Conceito ORDER BY, LIMIT e OFFSET](./images/Teste-ConceitoOrderByLimitOffset.png)

---

### Funções de agregação

Nesta aula aprenderemos como trabalhar com as funções de agregação para integrar registros em um único resultado. Nosso primeiro passo será conhecer os comandos de agregação mais comuns.

```sql
-- COUNT - Retorna a quantidade de registros
-- SUM -   Retorna a soma dos registros
-- MAX -   Retorna o maior valor dos registros
-- MIN -   Retorna o menor valor dos registros
-- AVG -   Retorna a média dos registros
```

Na [documentação do postgre](https://www.postgresql.org/docs/current/functions-aggregate.html) existem várias outras funções de agregação que podemos explorar, mas trabalharemos com as principais. Para isso, voltaremos à tabela "funcionarios" com SELECT * FROM funcionarios; e nos basearemos no "id" para realizarmos as agregações.

Para contarmos os registros da nossa tabela, utilizaremos o COUNT() . Esse comando aceita um nome de um campo ou o * , representa todos os campos. No nosso caso, utilizaremos o campo "id".

```sql
SELECT COUNT (id)
  FROM funcionarios;
```

Ao executarmos esse comando, teremos o retorno de quantos registros existem no nosso banco, que no caso são "7". Caso alteremos o número "id", como nas aulas passadas, esse comando continuará retornando a quantidade de registros, e não o valor do "id" mais alto.

O comando SUM() soma os valores. Ao codarmos SUM(id) ele retornará "28", ou seja, o somatório do valor de cada "id". Em outras palavras, esse comando calculou "1+2+3+4+5+6+7 = 28".

Ao escrevermos o comando MAX(), o programa retorna o maior valor do campo declarado, portanto MAX(id) resulta em "7", o maior "id". Por outro lado, para sabermos o menor "id", codamos MIN(id), que retorna "1".

O comando AVG() irá retornar a média dos valores, então AVG(id) retorna o número "4", porque é o resultado da soma de todos os valores (28) dividida pela quantidade de registros (7).

O valor da média é sucedido por várias casas decimais, por isso precisamos aumentar a coluna "avg" para visualizar esse valor. Para reduzir a quantidade de casas decimais, codamos ROUND() . Esse comando arredonda o resultado entre parênteses, diminuindo as casas decimais para um valor declarado. Por exemplo, para termos apenas duas casas decimais na nossa média, podemos escrever ROUND(AVG(id), 2) . Para vermos apenas o número inteiro, declaramos a quantidade de casas decimais como "0".

```sql
SELECT COUNT (id),
       SUM(id),
       MAX(id),
       MIN(id),
       ROUND(AVG(id),0)
  FROM funcionarios;
```

![Tela Retorno Select com Funções de Agregação](./images/TelaRetornoFuncoesAgregacao.png)

Basicamente essas são as funções de agregação. Conseguimos agrupar os valores e retornamos, em um único registro, os valores agrupamentos de cada comando.

Na próxima aula aprenderemos os comandos GROUP BY's, que permitem outras manipulações de agrupamento.

---

### Agrupando consultas

